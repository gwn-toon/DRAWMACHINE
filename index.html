<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DRAW</title>
<link href="https://fonts.cdnfonts.com/css/ocr-a-extended" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/aws-sdk@2.1485.0/dist/aws-sdk.min.js"></script>

<style>
/* ===========================================
   ROOT + GLOBAL
   =========================================== */
:root{
  --sidebar-width-base: 200px;
  --bar-thickness: 14px;
  --margin-size: 24px;

  /* base sizes inside sidebar */
  --cube-size-base: 43px;
  --grid-gap-base: 11px;
  --sidebar-vert-gap-base: 10px;   /* vertical gaps (tweakable) */
  --ocr-font-big-base: 50px;
  --ocr-font-preview-base: 40px;

  /* scale factors */
  --ui-scale: 1;
  --ui-tweak-boxes: 1;
  --ui-tweak-boxes-border: 1;

  --start-cube-size: 45px;
  --custom-pointer-cursor: auto;

}



/* STEPWISE SCALING BREAKPOINTS (height-based) */
@media (max-height: 670px) {
  :root {
    --ui-scale: 0.9;          /* first shrink step */
    --ui-tweak-boxes: 0.82;
    --ui-tweak-boxes-border: 1;
  }
}

/* THIRD BREAKPOINT — stop shrinking and make sidebar scrollable */
@media (max-height: 524px) {
  /* Freeze the scale (don’t shrink further) */
  :root {
    --ui-scale: 0.9;
    --ui-tweak-boxes: 0.82;
    --ui-tweak-boxes-border: 1;
  }

  /* Only now: internal scroll in sidebar */
.sidebar-scroll {
    overflow-y: auto;   /* vertical scroll ONLY inside padding box */
    overflow-x: visible;
    scrollbar-gutter: stable both edges;
  }
}

html,body{
  margin:0;
  background:#ddd;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
}

.app{
  display:flex;
  height:100vh;
  width:100vw;
  overflow:hidden;
}

/* ===========================================
   SIDEBAR
   =========================================== */

/* Outer sidebar: fixed padding + fixed width, NO clipping */
.sidebar{
  width: calc(var(--sidebar-width-base) * var(--ui-scale));
  height: 100%;
  background: #ddd;
  padding-top: var(--margin-size);
    padding-bottom: var(--margin-size);
    padding-left: calc(var(--margin-size) - 3px);
    padding-right: calc(var(--margin-size) - 3px);
  box-sizing: border-box;

  /* IMPORTANT: do NOT clip edges horizontally */
  overflow: visible;
  display:flex;
  flex-direction:column;
  position: relative; /* ADD THIS */
}

/* Inner scroll area: fills between paddings */
.sidebar-scroll {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    overflow-x: visible;
    padding-left: 3px;
    padding-right: 3px;
    box-sizing: border-box;
}

.sidebar-content {
    display: flex;
    flex-direction: column;
    flex: 1;
    height: auto;   /* natural height → allows scroll */
}

.sidebar-strip {
    width: var(--bar-thickness);
    background: black;     /* same color as your canvas bars */
}

/* Top & bottom black bars */
.sidebar-bar,
.sidebar-bottom-bar{
  height: var(--bar-thickness);   /* fixed 14px black bars */
  background:black;
  border-radius:0;
}

/* spacing below top bar */
.sidebar-bar{
  margin-bottom: calc(var(--sidebar-vert-gap-base) * var(--ui-scale));
}

/* spacing above lower bar */
.sidebar-bottom-bar{
  margin-top: calc(var(--sidebar-vert-gap-base) * var(--ui-scale));
}

/* Selector grid */
.selector-grid{
  display:grid;
  grid-template-columns: repeat(3, calc(var(--cube-size-base) * var(--ui-tweak-boxes)));
  gap: calc(var(--grid-gap-base) * var(--ui-tweak-boxes));
  padding-left: 1px;
  padding-right: 1px;
}

.selector-cell{
  background:#fff;
  border: calc(2px * var(--ui-scale)) solid black;
  aspect-ratio:1/1;
  display:flex;
  align-items:center;
  justify-content:center;
  box-sizing:border-box;
  user-select:none;
  transition: transform .12s, opacity .2s, border-color .12s;
  transform-origin: center;
  overflow: hidden;
}

.selector-cell:hover{
  cursor: pointer;
  transform: scale(1.15);
  border: 0px;
}

.selector-cell.hidden{
  visibility:hidden;
  opacity:0;
}

.selector-cell.selected{
  outline: calc(1px * var(--ui-scale)) solid black;
  border: calc(3px * var(--ui-scale)) solid black;
  transform:scale(1.1);
}

.selector-cell.punished{
  background: #ddd !important;
  border: 2px solid #333 !important;
  transform: none !important;
  outline: none !important;
  pointer-events: none;
}

.selector-cell svg{
  width:80%;
  height:80%;
  pointer-events:none;
}

.selector-cell[data-pattern="eraser"] svg {
  width: 90% !important;
  height: 90% !important;
}

.brush-square {
  font-family: "OCR A Extended", monospace;
  font-size: calc(40px * var(--ui-tweak-boxes));
  letter-spacing: 1px;
}

/* PREVIEW CELLS */
.preview-grid {
  margin-top: calc(var(--sidebar-vert-gap-base) * var(--ui-tweak-boxes));
}

.preview-cell {
  pointer-events: none;       /* not selectable */
  transition: transform 0.20s cubic-bezier(.3,1.7,.6,1);
  outline: none;   /* no selection outline */
}

#previewSize {
  font-family: "OCR A Extended", monospace;
  font-size: calc(var(--ocr-font-preview-base) * var(--ui-tweak-boxes));
}

.preview-hidden {
    opacity: 0;
    visibility: hidden;
}

@keyframes preview-pop {
  0%   { transform: scale(1); }
  70%  { transform: scale(1.15); }
  100% { transform: scale(1); }
}

.preview-pop {
    transform: scale(1.18);
}

/* Reset / Save block takes remaining height */
.reset-block {
  display: flex;
  flex-direction: column;
  flex: 1;
  margin-top: calc(var(--sidebar-vert-gap-base) * var(--ui-scale));
}

/* Zwarte balken boven en onder de knop (zelfde stijl als de andere) */
.reset-bar {
  height: var(--bar-thickness);    /* fixed 14px */
  background: black;
  border-radius: 0;
}

/* De knop zelf */
.reset-btn {
  width: 100%;
  background: #ffffff;
  border: none;
  cursor: pointer;
  align-items: center;
  justify-content: center;
  flex: 1;
  display: flex;
  min-height: calc(60px * var(--ui-scale));
}

.reset-text{
  position: relative;
  left: -2px;
  font-family: "OCR A Extended", monospace;
  font-size: calc(var(--ocr-font-big-base) * var(--ui-scale));
  letter-spacing: calc(-6px * var(--ui-scale));
  font-weight: 300;
}

/* Geen scale-effect zoals je selector-cubes (ziet er dan strakker uit) */
.reset-btn:hover, .reset-text:hover {
  background: red;
  color: white;
}

.export-block {
  display: none;
  flex-direction    : column;
  flex: 1;
}

.export-btn {
  width: 100%;
  background: #ffffff;
  border: none;
  cursor: pointer;
  align-items: center;
  justify-content: center;
  flex: 1;
  display: flex;
  min-height: calc(60px * var(--ui-scale));
}

.export-text {
  font-family: "OCR A Extended", monospace;
  font-size: calc(var(--ocr-font-big-base) * var(--ui-scale));
  letter-spacing: calc(-6px * var(--ui-scale));
  position: relative;
  left: -4px;
}

.export-btn:hover, .export-text:hover {
  background: #00ff00;
  color: white;
}

/* When the small-mode button shows RESET → red hover */
.reset-btn[data-mode="reset"]:hover,
.reset-btn[data-mode="reset"] .reset-text:hover {
  background: red;
  color: white;
}

/* When the small-mode button shows EXP-> → green hover */
.reset-btn[data-mode="export"]:hover,
.reset-btn[data-mode="export"] .reset-text:hover {
  background: #00ff00;
  color: white;
}

.divider-bar {
  height: var(--bar-thickness);   /* fixed 14px */
  background: black;
  display: none; /* hidden until fullscreen */
}

/* Fullscreen export block & divider behavior */
@media (min-height: 780px) {
  .export-block {
    display: flex;
  }
  .divider-bar {
    display: block;
  }
  #reset-btn-bar {
    display: none;
  }
  #export-btn-bar {
    display: none;
  }
}

#resetButton[data-mode="export"] .reset-text {
  position: relative;
  left: -4px;   /* adjust this amount */
}

/* ===========================================
   CANVAS AREA
   =========================================== */
.canvas-area{
  flex:1;
  display:flex;
  overflow:hidden;
  background:#ddd;
}

/* Canvas box itself */
.canvas-wrap{
  background:white;

  border-left: var(--bar-thickness) solid black;
  border-right: var(--bar-thickness) solid black;

  margin-top: var(--margin-size);
  margin-right: var(--margin-size);
  margin-bottom: var(--margin-size);
  margin-left:0;

  flex:1;
  display:flex;
  align-items:flex-start;
  justify-content:flex-start;
  overflow:hidden;
  position:relative;
}

/* Canvas element */
.inner-canvas{
  display:block;
  background:white;
  image-rendering: pixelated;
}

.prompt-overlay {
    position: absolute;
    inset: 0;
    background: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    z-index: 10;
    pointer-events: none;   /* important – so click still reaches canvas */
    opacity: 1;
}

.prompt-overlay.hidden {
    opacity: 0;
    pointer-events: none;
}

#promptOverlayText {
    font-family: "OCR A Extended", monospace;
    font-size: 72px;   /* adjust size */
    letter-spacing: -3px;
    color: #ff0000;
    margin-bottom: 5px;
}

#click-overlay {
    font-family: "OCR A Extended", monospace;
    font-size: 22px;        /* smaller subtitle */
    display: none;
}

#click-overlay-2 {
    font-family: "OCR A Extended", monospace;
    font-size: 35px;        /* smaller subtitle */
    display: none;
    color: #ff0000;
}

#exportMessageOverlay {
  position: absolute;
  inset: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  background: rgba(255,255,255,);
  opacity: 0;
  pointer-events: none;
}

#exportMessageOverlay.show {
  opacity: 1;
}

#exportMessageText {
  font-family: "OCR A Extended", monospace;
  font-size: 35px;
  color: red;
  text-align: center;
}

/* ===========================================
   TOP BAR (fullscreen only)
   =========================================== */

/* TOP BAR (default: hidden) */
.top-bar {
  display: none;                       /* completely gone by default */
  height: 50px;
  margin: 24px 24px 24px 24px;         /* 24 top, sides, bottom */
  grid-template-columns: auto 1fr auto;
  column-gap: 0px;                     /* black bars between sections */
}

.top-item {
  background: white;
  font-family: "OCR A Extended", monospace;
  font-size: 28px;
  display: flex;
  align-items: center;
  justify-content: left;
  letter-spacing: -3px;
  padding-top: 2px;
  padding-left: 15px;
  padding-right: 15px;
}

#prompt {
  border-left: 14px solid black;
  border-right: 14px solid black;
}


#leave {
  border-left: 14px solid black;
  border-right: 14px solid black;
  border-top: none;
  border-bottom: none;
  cursor: pointer;
}

#leave:hover {
    color: white;
    background-color: #ff0000;
}

#promptTarget {
  color: red;   /* pick any color */
  display: inline-block;
}

.promptBracket {
  color: red;
}

/* Prevent stutter: fixed-width box for the cycling word */
.promptWordBox {
  display: inline-block;
  width: 90px;       /* adjust to fit your longest word */
  text-align: center; /* centers the changing word */
  white-space: nowrap;
}

.top-item.scroller {
    position: relative;
    overflow: visible; /* changed! */
    min-width: 0;
    display: flex;
    align-items: center;
    padding-left: 19px;
    padding-right: 19px;
}

/* INNER MASK LAYER */
.top-item.scroller .mask {
    overflow: hidden;
    white-space: nowrap;
    position: relative;
}

/* Track with two identical copies */
.scroll-track {
  display: inline-flex;
  white-space: nowrap;
  animation: scroll-left 15s linear infinite;
}

/* Perfectly equal blocks */
.scroll-text {
  font-family: "OCR A Extended", monospace;
  font-size: 28px;
  letter-spacing: -3px;
  display: inline-block;
  padding-right: 0px; /* REQUIRED gap tuning */
  white-space: nowrap;
}

@keyframes scroll-left {
  0%   { transform: translateX(0); }
  100% { transform: translateX(-50%); }
}

/* =========================================================
   FULLSCREEN MODE — top bar + perfect no-scroll scaling
   =========================================================*/
@media (min-height: 780px) {

  /* 1. Show top bar */
  .top-bar {
    display: grid;
  }

  /* 2. Shrink the app container's vertical space so everything fits */
  .app {
    height: calc(100dvh - 98px); /* 24 top + 50 bar + 24 bottom */
    overflow: hidden;
  }

  /* 3. Sidebar: allow Reset/Save to stretch while cubes stay fixed */
  .reset-block,
  .export-block {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
  }

  /* 4. Reset and Save stretch evenly but don’t collapse too much */
  .reset-btn,
  .export-btn {
    flex: 1;
    min-height: 60px;
  }

  .canvas-wrap {
    margin-top: 0px !important;
  }

  .sidebar {
    padding-top: 0px;
  }

  #reset-bar-under {
    display: none
  }

  #export-bar-top {
    display: none
  }
}

/* ===========================================
   RED FLASH
   =========================================== */
#flashOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: red;
  opacity: 0;
  pointer-events: none; /* do not block clicks */
  transition: opacity 80ms linear;
  z-index: 9999; /* above everything */
}

/* ===========================================
   START SCREEN
   =========================================== */
/* START SCREEN ROOT – identical behavior to .app */
#startScreen {
    position: relative;
    height: 100vh;       /* locks layout to viewport height */
    width: 100vw;
    overflow: hidden;    /* removes ANY scroll */
    background: #ddd;

    display: flex;
    flex-direction: column;
}

/* Top bar: same margin system as your real top bar */
.start-top-bar {
    height: 50px;
    margin: var(--margin-size);
    margin-bottom: 0;
    background: white;
    border-left: var(--bar-thickness) solid black;
    border-right: var(--bar-thickness) solid black;

     /* absolutely required */
    display: none;
    align-items: center;
}

/* Start screen needs to scroll slightly faster */
.start-top-bar .scroll-track {
    animation: scroll-left-start 25s linear infinite;
}

@media (min-height: 780px) {
.start-top-bar {
    display: flex; /* same as before */
}
}

/* Custom animation identical path, just faster */
@keyframes scroll-left-start {
    0%   { transform: translateX(0); }
    100% { transform: translateX(-50%); }
}


/* Side bars container */
.start-frame {
    flex: 1; 
    display: flex;
    flex-direction: column;                   /* takes all remaining height */
    margin: var(--margin-size);    
  
    overflow: hidden;          /* same as drawing screen */
    position: relative;
    border-left: var(--bar-thickness) solid black;
    border-right: var(--bar-thickness) solid black;
}

.start-content {
    position: relative;
    width: 100%;
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center; /* centers everything horizontally */
}

.start-inner {
    flex: 0 0 auto;      
    display: flex;
    flex-direction: column;
    align-items: center;
}

.start-bottom {
    flex: 1;                            /* <<< the magic */
    
    display: flex;
    align-items: stretch;                /* center vertically */
    justify-content: center;            /* center horizontally */
    position: relative;
}


/* UNIVERSAL BOX COMPONENT (used by How To Use, Pick Color, Start button, etc.) */
.text-box {
    background: #ddd;
    border-left: var(--bar-thickness) solid black;
    border-right: var(--bar-thickness) solid black;

    margin-bottom: var(--margin-size);

    display: flex;
    justify-content: center;
    align-items: center;

    /* default size — you can override */
    padding-top: 10px;
    padding-bottom: 10px;
    padding-left: 15px;
    padding-right: 15px;

    /* typography matches toolkit style */
    font-family: "OCR A Extended", monospace;
    letter-spacing: -3px;
}

.start-red-text{
    color: #ff0000;
}

#box-1{
    font-size: 45px;
    background-color: white;
    margin-bottom: 10px;
}

#box-2{
    font-size: 28px;
    letter-spacing: -2px;
    border: none;
    margin-bottom: 5px;
}

#number-box{
    font-size: 28px;
    border: none;
    margin-bottom: 0px;
    margin-top: 0px;
    padding-bottom: 0px;
    padding-top: 0px;
}

.three-col-row {
    display: grid;

    /* This is the key */
    grid-template-columns:
        1fr      /* left column grows */
        auto     /* middle column stays exact width → centered */
        1fr;     /* right column grows */

    justify-items: center;        /* center each column’s content */
    align-items: start;

    column-gap: 60px;             /* adjust as needed */
    width: 100%;                  /* stretch row full width */
   
}

.col-block {
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* A container box specifically for rows of cubes */
.cube-box, .shape-box {
    margin-bottom: var(--margin-size);

    display: flex;
    justify-content: center;
    align-items: center;
}

.cube-row {
    display: flex;
    flex-direction: row;
    gap: 11px;               /* spacing between cubes — ADJUST FREELY */
}

.start-cube {
    width: var(--start-cube-size);
    height: var(--start-cube-size);

    border: 2px solid black;      /* matches selector-cell border look */
    box-sizing: border-box;
}

.start-number {
    width: var(--start-cube-size);
    height: var(--start-cube-size);

    display: flex;
    justify-content: center;
    align-items: center;

    background: white;
    border: 2px solid black;
    box-sizing: border-box;

    font-family: "OCR A Extended", monospace;
    font-size: 42px;
    letter-spacing: 1px;
    user-select: none;  /* same feel as toolbar */
}

.shape-grid {
    display: grid;
    grid-template-columns: repeat(5, auto);
    grid-template-rows: repeat(2, auto);

    /* Gap between shape cells — match toolbar */
    gap: 11px;
}

.shape-cell {
    width: var(--start-cube-size);
    height: var(--start-cube-size);

    background: white;
    border: 2px solid black;
    box-sizing: border-box;
    padding: 4px;

    display: flex;
    align-items: center;
    justify-content: center;

    overflow: hidden;
    user-select: none;
}

#start-eraser{
   padding: 2px;
}

#start-fill{
    padding: 3px;
}


/* Start Session Button */
.start-btn-box {
    background: white;
    border-left: var(--bar-thickness) solid black;
    border-right: var(--bar-thickness) solid black;
    padding: 15px 25px;

    font-family: "OCR A Extended", monospace;
    font-size: 55px;
    letter-spacing: -3px;
    cursor: pointer;
}

/* Hover effect: same logic as SAVE button */
#startButton:hover {
    background: #00ff00; /* bright green */
    color: white;
}

#startButton {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}

/* Base for all arrows */
.start-arrow {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 70px;
    height: 70px;
    animation: blink 0.8s infinite;
    pointer-events: none;
}

.arrow-left {
    left: -120px;
    transform: translateY(-50%) rotate(-90deg);
}

.arrow-right {
    right: -120px;
    transform: translateY(-50%) rotate(90deg);
}

.start-border-wrap {
  width: 100%;
  padding: 24px;
  padding-top: 0px;
  box-sizing: border-box; /* important! */
}

.start-border {
  height: var(--bar-thickness);
  background: black;
  width: 100%;
}



/* blinking animation */
@keyframes blink {
    0%   { opacity: 0; }
    49%  { opacity: 0; }
    50%  { opacity: 1; }
    100% { opacity: 1; }
}

@media (min-height: 900px) {
#box-1{
    font-size: 55px;
}
#box-2{
    font-size: 29px;
}
.start-btn-box{
    font-size: 65px;
}
:root{
--start-cube-size: 50px;
}
#start-fill{
    padding: 5px;
}
.start-number{
    font-size: 47px;
}
}

@media (min-height: 920px) {
#box-1{
    font-size: 65px;
}
#box-2{
    font-size: 35px;
}

#box-2, .text-box{
  padding-bottom: 14px;
}

#number-box, .text-box{
  font-size: 35px;
}

.start-btn-box{
    font-size: 75px;
}
:root{
--start-cube-size: 55px;
}
#start-fill{
    padding: 4px;
}
.start-number{
    font-size: 51px;
}
}

@media (max-height: 735px){
  .start-content{
    overflow-y: auto;
  }
}

@media (max-width: 754px){
  .arrow-left{
    left: -100px;
  }
  .arrow-right{
    right: -100px;
  }

  .three-col-row {
    grid-template-columns: 1fr;     /* collapse to 1 column */
    row-gap: 0px;                   /* spacing between fields (tune as needed) */
  }

  .col-block {
    width: 100%;                     /* optional: stretch blocks full width */
    display: flex;
    flex-direction: column;
    align-items: center;             /* keep icons centered */
  }

  .start-content{
    overflow-y: auto;
  }
}

@media (max-width: 665px){
  .arrow-left{
    display: none;
  }

  .arrow-right{
    display: none;
  }
}

/* Force custom pointer cursor everywhere that would normally show a hand */
a,
button,
[role="button"],
.selector-cell:hover,
.reset-btn,
#leave,
.start-btn-box,
[onclick] {
  cursor: var(--custom-pointer-cursor) !important;
}


</style>
</head>

<body>

    <!-- START SCREEN -->
<div id="startScreen">
    <div class="start-top-bar">
        <div class="top-item scroller">
            <div class="mask">
                <div class="scroll-track">
                    <span class="scroll-text">&nbsp;DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE -</span>
                    <span class="scroll-text">&nbsp;DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE -</span>
                </div>
            </div>
        </div>
    </div>

<div class="start-frame">
    <div class="start-content">
        <div class="start-inner">
        <div class="text-box" id="box-1">
            DRAW MACHINE GUIDE
        </div>
        <div class="text-box" id="box-2">
            <span class="start-red-text">COLOR</span>&nbsp;OPTIONS:
        </div>
        <div class="cube-box">
            <div class="cube-row">
                <div class="start-cube" style="background:#ffff00;"></div>
                <div class="start-cube" style="background:#00ff00;"></div>
                <div class="start-cube" style="background:#ff0000;"></div>
                <div class="start-cube" style="background:#00ffff;"></div>
                <div class="start-cube" style="background:#0000ff;"></div>
                <div class="start-cube" style="background:#ff00ff;"></div>
            </div>
        </div>
        <div class="text-box" id="box-2">
            <span class="start-red-text">SIZE</span>&nbsp;OPTIONS:
        </div>
        <div class="cube-box">
            <div class="cube-row">
                <div class="start-number">1</div>
                <div class="start-number">2</div>
                <div class="start-number">3</div>
                <div class="start-number">4</div>
                <div class="start-number">5</div>
                <div class="start-number">6</div>
            </div>
        </div>
        <div class="text-box" id="box-2">
            <span class="start-red-text">BRUSH</span>&nbsp;OPTIONS:
        </div>
<div class="three-col-row">
    <div class="col-block">
        <div class="text-box" id="number-box"><span class="start-red-text">1.</span></div>
        <div class="text-box" id="box-2">
            SOLID
        </div>
        <div class="shape-box">
            <div class="shape-cell" id="start-fill">
                <svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0.5" y="0.5" width="19" height="19"
                      fill="none" stroke="currentColor" stroke-width="4.3"/>
                    <path d="M2 2 L18 18 M2 18 L18 2"
                      stroke="currentColor" stroke-width="3" fill="none"/></svg>
            </div>
        </div>
    </div>
    <div class="col-block">
        <div class="text-box" id="number-box"><span class="start-red-text">2.</span></div>
        <div class="text-box" id="box-2">
          SHAPES
        </div>
        <div class="shape-box">
            <div class="shape-grid">
        
                <div class="shape-cell">
                    <svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path d="M2 2 L18 18 M2 18 L18 2" 
                         stroke="currentColor" stroke-width="3" fill="none"/></svg>
                </div>
        
                <div class="shape-cell">
                    <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="5" cy="5" r="1.89"
                          fill="currentColor" stroke="currentColor" stroke-width="1.5"/></svg>
                </div>
        
                <div class="shape-cell">
                    <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="5" cy="5" r="3.32"
                          fill="currentColor" stroke="currentColor" stroke-width="1.5"/></svg>
                </div>
        
                <div class="shape-cell">
                    <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                        <rect x="3.11" y="3.11" width="3.79" height="3.79"
                          fill="currentColor" stroke="currentColor" stroke-width="1.5"/></svg>
                </div>
        
                <div class="shape-cell">
                    <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                        <rect x="1.68" y="1.68" width="6.64" height="6.64"
                          fill="currentColor" stroke="currentColor" stroke-width="1.5"/></svg>
                </div>
        
                <!-- second row -->
        
                <div class="shape-cell">
                    <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                        <path d="M0 5 L10 5 M5 0 L5 10"
                          fill="none" stroke="currentColor" stroke-width="1.5"/></svg>
                </div>
        
                <div class="shape-cell">
                    <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="5" cy="5" r="1.89"
                          fill="none" stroke="currentColor" stroke-width="1.5"/></svg>
                </div>
        
                <div class="shape-cell">
                    <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="5" cy="5" r="3.32"
                          fill="none" stroke="currentColor" stroke-width="1.5"/></svg>
                </div>
        
                <div class="shape-cell">
                    <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                        <rect x="3.11" y="3.11" width="3.79" height="3.79"
                          fill="none" stroke="currentColor" stroke-width="1.5"/></svg>
                </div>
        
                <div class="shape-cell">
                    <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                        <rect x="1.68" y="1.68" width="6.64" height="6.64"
                          fill="none" stroke="currentColor" stroke-width="1.5"/></svg>
                </div>
            </div>
        
        </div>
    </div>
    <div class="col-block">
        <div class="text-box" id="number-box"><span class="start-red-text">3.</span></div>
        <div class="text-box" id="box-2">
            ERASER
        </div>
        <div class="shape-box">
            <div class="shape-cell" id="start-eraser">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10">
                    <rect x="2.18" y="4.52" width="3.31" height="3.31"
                      transform="translate(5.48 -0.9) rotate(45)"
                      fill="none" stroke="currentColor" stroke-width="1.2"/>
                    <rect x="4.52" y="2.18" width="3.31" height="3.31"
                      transform="translate(4.52 -3.24) rotate(45)"
                      fill="currentColor" stroke="currentColor" stroke-width="1.2"/>
                  </svg>
            </div>
        </div>
    </div>
</div>
</div>
  
<div class="start-bottom">

    <div id="startButton" class="start-btn-box">
        START DRAWING
    
        <div class="start-arrow arrow-left">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                <!-- vertical line centered at x=10 -->
                <line x1="10" y1="5" x2="10" y2="12"
                      stroke="#000" stroke-width="2" stroke-linecap="square"/>
            
                <!-- arrowhead centered on x=10 -->
                <polyline points="6,10 10,14 14,10"
                          fill="none" stroke="#000" stroke-width="2"
                          stroke-linecap="square"/>
            </svg>
        </div>
    
        <div class="start-arrow arrow-right">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                <!-- vertical line centered at x=10 -->
                <line x1="10" y1="5" x2="10" y2="12"
                      stroke="#000" stroke-width="2" stroke-linecap="square"/>
            
                <!-- arrowhead centered on x=10 -->
                <polyline points="6,10 10,14 14,10"
                          fill="none" stroke="#000" stroke-width="2"
                          stroke-linecap="square"/>
            </svg>
        </div>
    </div>
</div>
</div>
</div>

</div>
</div>
</div>
    

 <!-- DRAWING SCREEN -->
<div id="drawingScreen" style="display:none;">
    <!-- ================= TOPBAR ================= -->
    <div class="top-bar">
        <div class="top-item" id="prompt">
            PROMPT: DRAW A&nbsp;
            <span class="promptBracket leftBracket">&lt;</span>
            <span class="promptWordBox">
              <span id="promptTarget"></span>
            </span>
            <span class="promptBracket rightBracket">&gt;</span>
          </div>
          
          
        <div class="top-item scroller">
            <div class="mask">
            <div class="scroll-track">
              <span class="scroll-text">&nbsp;DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE -</span>
              <span class="scroll-text">&nbsp;DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE - DRAW MACHINE -</span>
            </div>
            </div>
        </div>
        <button class="top-item" id="leave">LEAVE SESSION -></button>
    </div>
   
    <div class="app">
      <!-- ================= SIDEBAR ================= -->
      <aside class="sidebar">
        <div class="sidebar-scroll">
            <div class="sidebar-strip"></div>
            <div class="sidebar-content">
      
          <div class="sidebar-bar"></div>
          <div id="selectorGrid" class="selector-grid"></div>
          <div class="sidebar-bottom-bar"></div>
      
          <div id="previewBar" class="selector-grid preview-grid">
            <div id="previewColor" class="selector-cell preview-cell"></div>
            <div id="previewPattern" class="selector-cell preview-cell"></div>
            <div id="previewSize" class="selector-cell preview-cell"></div>
          </div>
      
          <div class="reset-block">
            <div class="reset-bar"></div>
            <button id="resetButton" class="reset-btn">
              <span class="reset-text">RESET</span>
            </button>
            <div class="reset-bar" id="reset-bar-under"></div>
          </div>
      
          <div class="divider-bar"></div>
      
          <div id="exportBlock" class="export-block">
            <div class="reset-bar" id="export-bar-top"></div>
            <button id="exportButton" class="export-btn">
              <span class="export-text">SAVE</span>
            </button>
            <div class="reset-bar"></div>
          </div>
         </div>
        </div>
      </aside>
      

      <!-- ================= CANVAS ================= -->
      <div class="canvas-area">
        <div class="canvas-wrap">
            <div id="promptOverlay" class="prompt-overlay">
                <div id="click-overlay-2">DRAW A</div>
                <div id="promptOverlayText"></div>
                <div id="click-overlay">*CLICK TO START DRAWING*</div>
            </div>
            <div id="exportMessageOverlay" class="hidden">
                <div id="exportMessageText">DRAWING EXPORTED TO VIEWMACHINE</div>
            </div>
          <canvas id="innerCanvas" class="inner-canvas"></canvas>
        </div>
      </div>
    </div>
</div>
    <div id="flashOverlay"></div>
    <audio id="eraseSound" src="buzzer.mp3"></audio>


<script src="https://cdn.jsdelivr.net/npm/aws-sdk@2.1485.0/dist/aws-sdk.min.js"></script>

<script>
    /* ===========================================
       CONFIG & CONSTANTS
    =========================================== */
    const eraseSound = document.getElementById("eraseSound");
    
    const colorOptions = ["#0000ff", "#00ff00", "#ff0000", "#ffff00", "#ff00ff", "#00ffff"];
    const brushSizes   = [1,2,3,4,5,6];
    
    const brushPatterns = [
      "fill","cross","box-line","box-filled",
      "circle-line","circle-filled","plus",
      "box-small-line","box-small-filled",
      "circle-small-line","circle-small-filled",
      "eraser"
    ];
    
    /* SVGs for toolbar preview */
    const brushSVGs = {
      "box-line":`<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
        <rect x="1.68" y="1.68" width="6.64" height="6.64"
          fill="none" stroke="currentColor" stroke-width="1.5"/></svg>`,
      "box-filled":`<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
        <rect x="1.68" y="1.68" width="6.64" height="6.64"
          fill="currentColor" stroke="currentColor" stroke-width="1.5"/></svg>`,
      "cross": `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
        <path d="M2 2 L18 18 M2 18 L18 2" 
         stroke="currentColor" stroke-width="3" fill="none"/></svg>`,
      "circle-line":`<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
        <circle cx="5" cy="5" r="3.32"
          fill="none" stroke="currentColor" stroke-width="1.5"/></svg>`,
      "circle-filled":`<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
        <circle cx="5" cy="5" r="3.32"
          fill="currentColor" stroke="currentColor" stroke-width="1.5"/></svg>`,
      "plus":`<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
        <path d="M0 5 L10 5 M5 0 L5 10"
          fill="none" stroke="currentColor" stroke-width="1.5"/></svg>`,
      "box-small-line":`<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
        <rect x="3.11" y="3.11" width="3.79" height="3.79"
          fill="none" stroke="currentColor" stroke-width="1.5"/></svg>`,
      "box-small-filled":`<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
        <rect x="3.11" y="3.11" width="3.79" height="3.79"
          fill="currentColor" stroke="currentColor" stroke-width="1.5"/></svg>`,
      "circle-small-line":`<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
        <circle cx="5" cy="5" r="1.89"
          fill="none" stroke="currentColor" stroke-width="1.5"/></svg>`,
      "circle-small-filled":`<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
        <circle cx="5" cy="5" r="1.89"
          fill="currentColor" stroke="currentColor" stroke-width="1.5"/></svg>`,
      "fill":`<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
        <rect x="0.5" y="0.5" width="19" height="19"
          fill="none" stroke="currentColor" stroke-width="4.3"/>
        <path d="M2 2 L18 18 M2 18 L18 2"
          stroke="currentColor" stroke-width="3" fill="none"/></svg>`,
      "eraser":`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10">
        <rect x="2.18" y="4.52" width="3.31" height="3.31"
          transform="translate(5.48 -0.9) rotate(45)"
          fill="none" stroke="currentColor" stroke-width="1.2"/>
        <rect x="4.52" y="2.18" width="3.31" height="3.31"
          transform="translate(4.52 -3.24) rotate(45)"
          fill="currentColor" stroke="currentColor" stroke-width="1.2"/>
      </svg>`
    };
    
    /* Red cross SVG (for punished cubes) */
    const redCrossSVG = `
    <svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
      <path d="M2 2 L18 18 M2 18 L18 2" 
           stroke="#ff0000" stroke-width="4" fill="none"/></svg>`;
    
    /* ============ R2 CONFIG (kept for reference, not used directly here) ============ */
    const R2_BUCKET = "toolkit-images";

    /* ===========================================
   CURSOR SVGs (10×10 px, black only)
   =========================================== */

    const cursor_cross = `
    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10">
    <path d="M0 0 L10 10 M0 10 L10 0" stroke="black" stroke-width="2"/>
    </svg>`;

    const cursor_plus = `
    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10">
    <path d="M0 5 L10 5 M5 0 L5 10" stroke="black" stroke-width="2"/>
    </svg>`;

    const cursor_box_line = `
    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10">
    <rect x="1.68" y="1.68" width="6.64" height="6.64" fill="none" stroke="black" stroke-width="2"/>
    </svg>`;

    const cursor_box_filled = `
    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10">
    <rect x="1.68" y="1.68" width="6.64" height="6.64" fill="black" stroke="black" stroke-width="2"/>
    </svg>`;

    const cursor_box_small_line = `
    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10">
    <rect x="3.11" y="3.11" width="3.79" height="3.79" fill="none" stroke="black" stroke-width="2"/>
    </svg>`;

    const cursor_box_small_filled = `
    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10">
    <rect x="3.11" y="3.11" width="3.79" height="3.79" fill="black" stroke="black" stroke-width="2"/>
    </svg>`;

    const cursor_circle_line = `
    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10">
    <circle cx="5" cy="5" r="3.32" fill="none" stroke="black" stroke-width="2"/>
    </svg>`;

    const cursor_circle_filled = `
    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10">
    <circle cx="5" cy="5" r="3.32" fill="black" stroke="black" stroke-width="2"/>
    </svg>`;

    const cursor_circle_small_line = `
    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10">
    <circle cx="5" cy="5" r="1.89" fill="none" stroke="black" stroke-width="2"/>
    </svg>`;

    const cursor_circle_small_filled = `
    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10">
    <circle cx="5" cy="5" r="1.89" fill="black" stroke="black" stroke-width="2"/>
    </svg>`;

    const cursor_fill = `
    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10">
    <rect x="0" y="0" width="10" height="10" fill="black"/>
    </svg>`;

    const cursor_eraser = `
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 10 10">
      <!-- black tilted eraser body (bigger + squarer) -->
      <rect x="2.18" y="4.52" width="3.31" height="3.31"
              transform="translate(5.48 -0.9) rotate(45)"
              fill="white" stroke="currentColor" stroke-width="1.2"/>
            <rect x="4.52" y="2.18" width="3.31" height="3.31"
              transform="translate(4.52 -3.24) rotate(45)"
              fill="currentColor" stroke="currentColor" stroke-width="1.2"/>
    </svg>`;

    const cursor_pointer = `
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 10 10">
      <path
        d="M3 6 L5 4 L7 6"
        fill="none"
        stroke="black"
        stroke-width="1"
        stroke-linecap="square"
        stroke-linejoin="miter"
      />
    </svg>`;


    const CURSOR_SVGS = {
    "fill": cursor_fill,
    "cross": cursor_cross,
    "plus": cursor_plus,
    "box-line": cursor_box_line,
    "box-filled": cursor_box_filled,
    "box-small-line": cursor_box_small_line,
    "box-small-filled": cursor_box_small_filled,
    "circle-line": cursor_circle_line,
    "circle-filled": cursor_circle_filled,
    "circle-small-line": cursor_circle_small_line,
    "circle-small-filled": cursor_circle_small_filled,
    "eraser": cursor_eraser,
    "pointer": cursor_pointer,

    };

    
    
    /* ===========================================
       CANVAS SETUP
    =========================================== */
    const canvas = document.getElementById("innerCanvas");
    const dpr    = window.devicePixelRatio || 1;
    
    const COLS      = 180;
    const ROWS      = 110;
    const CELL_SIZE = 10;
    
    const cssWidth  = COLS * CELL_SIZE;
    const cssHeight = ROWS * CELL_SIZE;
    
    canvas.width  = cssWidth  * dpr;
    canvas.height = cssHeight * dpr;
    canvas.style.width  = cssWidth  + "px";
    canvas.style.height = cssHeight + "px";
    
    const ctx = canvas.getContext("2d");
    ctx.scale(dpr, dpr);
    
    /* Pixel state */
    const cells = Array.from({ length: ROWS * COLS }, () => ({
      fillColor: null,
      shapes: []
    }));
    
    /* ===========================================
       STATE
    =========================================== */
    let selectedColorBox   = null;
    let selectedBrushBox   = null;
    let selectedPatternBox = null;
    let protectedExtraCube = null;

    let brushColor = "#0000ff";
    let brushSize  = 1;
    let brushShape = "fill";
    
    let disappearPercentage = 20;
    const countdownValue    = 40;
    let timerCountdown      = countdownValue;
    
    /* timers / prompt handles so we can start/stop cleanly */
    let hideTimerId = null;
    let promptCycleIntervalId = null;
    let promptCycleTimeoutId  = null;
    
    let drawingLocked = false;

    let saveLocked = false;


    /* ===========================================
      INACTIVITY / SESSION TIMEOUT
    =========================================== */

    const INACTIVITY_DELAY = 25000; // 20s
    const COUNTDOWN_DURATION = 5;

    let inactivityTimeout = null;
    let countdownInterval = null;
    let countdownRemaining = COUNTDOWN_DURATION;
    let isCountingDown = false;
    let sessionActive = false;

    /* ===========================================
       DOM REFERENCES
    =========================================== */
    const selectorGrid  = document.getElementById("selectorGrid");
    const selectorCount = 24;
    const selectorCells = [];
    
    const previewColor   = document.getElementById("previewColor");
    const previewPattern = document.getElementById("previewPattern");
    const previewSize    = document.getElementById("previewSize");
    
    const resetBtn    = document.getElementById("resetButton");
    const exportBtn   = document.getElementById("exportButton");
    const exportBlock = document.getElementById("exportBlock");
    
    /* ===========================================
       PREVIEW UPDATE
    =========================================== */
    function updatePreviews() {
      if (brushShape === "eraser") {
        previewColor.classList.add("preview-hidden");
      } else {
        previewColor.classList.remove("preview-hidden");
        previewColor.style.background = brushColor;
        previewColor.innerHTML = "";
      }
    
      previewPattern.innerHTML = brushSVGs[brushShape] || "";
      previewPattern.style.background = "#fff";
    
      previewSize.innerHTML = brushSize;
      previewSize.style.background = "#fff";
    }
    
    function popPreviewCell(el) {
      if (!el) return;
    
      el.classList.remove("preview-pop");
      void el.offsetWidth;
      el.classList.add("preview-pop");
    
      setTimeout(() => {
        el.classList.remove("preview-pop");
      }, 180);
    }

    /* ===========================================
   UPDATE CURSOR (global pointer icon)
   =========================================== */
    let ACTIVE_DRAW_CURSOR = "auto";
    let ACTIVE_POINTER_CURSOR = "auto";

    function updateCursor() {
      const svg = CURSOR_SVGS[brushShape];
      if (!svg) return;

      const encoded = `data:image/svg+xml;base64,${btoa(svg)}`;

      // IMPORTANT: apply to the element that actually owns fullscreen cursor scope
      const el = document.fullscreenElement || document.documentElement;

      // keep your current hotspot for now (you can refine per-shape later)
      ACTIVE_DRAW_CURSOR = `url("${encoded}") 5 5, auto`;

      // apply to both (so you’re covered when entering/leaving fullscreen)
      document.documentElement.style.cursor = ACTIVE_DRAW_CURSOR;
      el.style.cursor = ACTIVE_DRAW_CURSOR;
    }


    function updatePointerCursor() {
      const encoded = `data:image/svg+xml;base64,${btoa(cursor_pointer)}`;

      ACTIVE_POINTER_CURSOR = `url("${encoded}") 7 6, pointer`;

      document.documentElement.style.setProperty(
        "--custom-pointer-cursor",
        ACTIVE_POINTER_CURSOR
      );
    }

    updatePointerCursor();

    function ensureCursor() {
      const el = document.fullscreenElement || document.documentElement;

      // restore drawing cursor
      if (document.documentElement.style.cursor !== ACTIVE_DRAW_CURSOR) {
        document.documentElement.style.cursor = ACTIVE_DRAW_CURSOR;
      }
      if (el.style.cursor !== ACTIVE_DRAW_CURSOR) {
        el.style.cursor = ACTIVE_DRAW_CURSOR;
      }

      // restore hover-pointer cursor (CSS variable)
      if (getComputedStyle(document.documentElement).getPropertyValue("--custom-pointer-cursor").trim() !== ACTIVE_POINTER_CURSOR) {
        document.documentElement.style.setProperty("--custom-pointer-cursor", ACTIVE_POINTER_CURSOR);
      }
    }

     /* ===========================================
   INACTIVITY TIMER
   =========================================== */
   function startCountdown() {
    if (!sessionActive) return;

    isCountingDown = true;
    countdownRemaining = COUNTDOWN_DURATION;

    const overlay = document.getElementById("promptOverlay");
    const text    = document.getElementById("promptOverlayText");
    const sub     = document.getElementById("click-overlay-2");
    const subsub   = document.getElementById("click-overlay");

    sub.textContent = "LEAVING SESSION IN:";
    text.textContent = countdownRemaining;
    subsub.textContent = "*MOVE TO CANCEL*";

    overlay.classList.remove("hidden");

    document.addEventListener("mousemove", registerMouseMoveDuringCountdown);

    countdownInterval = setInterval(() => {
      countdownRemaining--;
      text.textContent = countdownRemaining;

      if (countdownRemaining <= 0) {
      location.reload();
    }

    }, 1000);
  }

  function cancelCountdown() {
    isCountingDown = false;

    clearInterval(countdownInterval);
    document.removeEventListener("mousemove", registerMouseMoveDuringCountdown);

    const overlay = document.getElementById("promptOverlay");
    overlay.classList.add("hidden");
  }


    function startSessionInactivity() {
      sessionActive = true;
      resetInactivityTimer();

      document.addEventListener("mousedown", registerActivity);
      document.addEventListener("touchstart", registerActivity);
      document.addEventListener("keydown", registerActivity);
    }

    function stopSessionInactivity() {
      sessionActive = false;

      clearTimeout(inactivityTimeout);
      clearInterval(countdownInterval);

      document.removeEventListener("mousedown", registerActivity);
      document.removeEventListener("touchstart", registerActivity);
      document.removeEventListener("keydown", registerActivity);
      document.removeEventListener("mousemove", registerMouseMoveDuringCountdown);
    }

    function registerActivity() {
      if (!sessionActive) return;

      resetInactivityTimer();

      if (isCountingDown) {
        cancelCountdown();
      }
    }

    function registerMouseMoveDuringCountdown() {
      if (!isCountingDown) return;
      cancelCountdown();
      resetInactivityTimer();
    }

    function resetInactivityTimer() {
      clearTimeout(inactivityTimeout);

      inactivityTimeout = setTimeout(() => {
        startCountdown();
      }, INACTIVITY_DELAY);
    }


    
    /* ===========================================
       SELECTOR GRID BUILD + RANDOMIZATION
    =========================================== */
    function buildSelectorCells() {
      selectorGrid.innerHTML = "";
      selectorCells.length   = 0;
    
      for (let i = 0; i < selectorCount; i++) {
        const el = document.createElement("div");
        el.className = "selector-cell";
        selectorGrid.appendChild(el);
        selectorCells.push(el);
      }
    
      // Colors
      const colorIdx = randomUnique(selectorCount, colorOptions.length);
      colorIdx.forEach((idx, i) => {
        const cell = selectorCells[idx];
        cell.classList.add("color-square");
        cell.dataset.color = colorOptions[i];
        cell.style.background = colorOptions[i];
      });
    
      // Brush sizes
      const brushIdx = randomUnique(selectorCount, brushSizes.length, new Set(colorIdx));
      brushIdx.forEach((idx, i) => {
        const cell = selectorCells[idx];
        cell.classList.add("brush-square");
        cell.dataset.size = brushSizes[i];
        cell.textContent  = brushSizes[i];
      });
    
      // Patterns
      const patternIdx = randomUnique(
        selectorCount,
        brushPatterns.length,
        new Set([...colorIdx, ...brushIdx])
      );
      patternIdx.forEach((idx, i) => {
        const cell = selectorCells[idx];
        const p    = brushPatterns[i];
        cell.classList.add("pattern-square");
        cell.dataset.pattern = p;
        cell.innerHTML = brushSVGs[p] || p;
      });
    
      // Random defaults (eraser excluded)
      selectedColorBox = selectorCells[colorIdx[Math.floor(Math.random() * colorIdx.length)]];
      selectedColorBox.classList.add("selected");
      brushColor = selectedColorBox.dataset.color;
    
      selectedBrushBox = selectorCells[brushIdx[Math.floor(Math.random() * brushIdx.length)]];
      selectedBrushBox.classList.add("selected");
      brushSize = parseInt(selectedBrushBox.dataset.size, 10);
    
      const patternCells = patternIdx
        .map(i => selectorCells[i])
        .filter(c => c.dataset.pattern !== "eraser");
    
      selectedPatternBox = patternCells[Math.floor(Math.random() * patternCells.length)];
      selectedPatternBox.classList.add("selected");
      brushShape = selectedPatternBox.dataset.pattern;
    
      randomizeSelectors();
      updatePreviews();
    
      // Click behavior
      selectorCells.forEach(cell => {
        cell.addEventListener("click", () => {
    
          // ERASER
          if (cell.dataset.pattern === "eraser") {
            flashRed();
    
            if (selectedPatternBox && selectedPatternBox !== cell) {
              selectedPatternBox.classList.remove("selected");
            }
    
            selectedPatternBox = cell;
            cell.classList.add("selected");
            brushShape = "eraser";
    
            punishRandomCube();
            updatePreviews(); 
            popPreviewCell(previewPattern);
            updateCursor();
            return;
          }
    
          if (cell.classList.contains("punished")) return;
    
          let needsRandomize = false;
    
          // COLOR
          if (cell.classList.contains("color-square")) {
            selectedColorBox.classList.remove("selected");
            selectedColorBox = cell;
            cell.classList.add("selected");
            brushColor = cell.dataset.color;
    
            updatePreviews();
            popPreviewCell(previewColor);
            needsRandomize = true;
          }
    
          // BRUSH SIZE
          else if (cell.classList.contains("brush-square")) {
            selectedBrushBox.classList.remove("selected");
            selectedBrushBox = cell;
            cell.classList.add("selected");
            brushSize = parseInt(cell.dataset.size, 10);
    
            updatePreviews();
            popPreviewCell(previewSize);
            needsRandomize = true;
          }
    
          // PATTERN
          else if (cell.classList.contains("pattern-square")) {
            selectedPatternBox.classList.remove("selected");
            selectedPatternBox = cell;
            cell.classList.add("selected");
            brushShape = cell.dataset.pattern;
            updateCursor();

            updatePreviews();
            popPreviewCell(previewPattern);
            needsRandomize = true;
          }
    
          if (needsRandomize) {
            randomizeSelectors();
            return;
          }
    
          randomizeSelectors();
          updatePreviews();
        });
      });
    }
    
    function randomUnique(total, need, blacklist = new Set()) {
      const arr = [];
      while (arr.length < need) {
        const i = Math.floor(Math.random() * total);
        if (!arr.includes(i) && !blacklist.has(i)) arr.push(i);
      }
      return arr;
    }
    
    /* Hide / show some selector cells */
    function randomizeSelectors() {
    const keep = new Set([selectedColorBox, selectedBrushBox, selectedPatternBox]);

    // Movable cubes = all non-selected, non-punished cells
    const movable = selectorCells.filter(c =>
        !keep.has(c) &&
        !c.classList.contains("punished")
    );

    // STEP 1 — choose 1 forced-visible cube
    let forcedVisible = null;
    if (movable.length > 0) {
        forcedVisible = movable[Math.floor(Math.random() * movable.length)];
    }

    // STEP 2 — clear all hidden classes
    movable.forEach(c => c.classList.remove("hidden"));

    // STEP 3 — compute how many to hide
    let hideCount = Math.floor(movable.length * (disappearPercentage / 100));

    // Never hide all movable cubes → always leave 1 extra visible
    if (movable.length - hideCount < 1) {
        hideCount = movable.length - 1;
    }

    // STEP 4 — perform random hiding EXCEPT forced-visible one
    const shuffled = movable.slice().sort(() => Math.random() - 0.5);
    const hideThese = [];

    for (let c of shuffled) {
        if (hideThese.length >= hideCount) break;
        if (c === forcedVisible) continue; // skip the protected cube
        hideThese.push(c);
    }

    hideThese.forEach(c => c.classList.add("hidden"));
}


    
    /* ===========================================
       ERASER PUNISHMENT LOGIC
    =========================================== */
    function punishRandomCube() {
      const candidates = selectorCells.filter(c =>
        !c.classList.contains("punished") &&
        !c.classList.contains("hidden") &&
        c.dataset.pattern !== "eraser" &&
        c !== selectedColorBox &&
        c !== selectedBrushBox &&
        c !== selectedPatternBox
      );
    
      if (candidates.length === 0) return;
    
      const punished = candidates[Math.floor(Math.random() * candidates.length)];
    
      eraseSound.currentTime = 0;
      eraseSound.play().catch(() => {});
    
      punished.classList.add("punished");
      punished.innerHTML = redCrossSVG;
      punished.style.background = "#ccc";
    }
    
    function flashRed() {
      const overlay = document.getElementById("flashOverlay");
      overlay.style.opacity = "0.7";
    
      setTimeout(() => {
        overlay.style.opacity = "0";
      }, 80);
    }

    
    /* ===========================================
       DRAWING HELPERS
    =========================================== */
    function getCellFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
    
      const col = Math.floor(x / CELL_SIZE);
      const row = Math.floor(y / CELL_SIZE);
    
      if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null;
      return { row, col };
    }
    
    function drawCell(row, col) {
      const idx  = row * COLS + col;
      const cell = cells[idx];
      const x = col * CELL_SIZE;
      const y = row * CELL_SIZE;
    
      ctx.save();
    
      ctx.clearRect(x, y, CELL_SIZE, CELL_SIZE);
      ctx.fillStyle = "white";
      ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
    
      if (cell.fillColor) {
        ctx.fillStyle = cell.fillColor;
        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
      }
    
      ctx.translate(x, y);
      for (const s of cell.shapes) {
        drawShape(ctx, CELL_SIZE, s.shape, s.color);
      }
      ctx.restore();
    
      const neighbors = [
        [row - 1, col],
        [row + 1, col],
        [row, col - 1],
        [row, col + 1],
        [row - 1, col - 1],
        [row - 1, col + 1],
        [row + 1, col - 1],
        [row + 1, col + 1]
      ];
    
      neighbors.forEach(([r, c]) => {
        if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return;
        drawNeighborOvershoot(r, c, row, col);
      });
    }
    
    function drawNeighborOvershoot(nr, nc, targetRow, targetCol) {
      const nIdx  = nr * COLS + nc;
      const nCell = cells[nIdx];
      if (!nCell) return;
    
      const x = targetCol * CELL_SIZE;
      const y = targetRow * CELL_SIZE;
    
      const dx = targetCol - nc;
      const dy = targetRow - nr;
    
      let clipX = x;
      let clipY = y;
      let clipW = CELL_SIZE;
      let clipH = CELL_SIZE;
    
      if (dx === 1) {
        clipW = CELL_SIZE / 2;
      } 
      else if (dx === -1) {
        clipX = x + CELL_SIZE / 2;
        clipW = CELL_SIZE / 2;
      }
    
      if (dy === 1) {
        clipH = CELL_SIZE / 2;
      } 
      else if (dy === -1) {
        clipY = y + CELL_SIZE / 2;
        clipH = CELL_SIZE / 2;
      }
    
      ctx.save();
      ctx.beginPath();
      ctx.rect(clipX, clipY, clipW, clipH);
      ctx.clip();
    
      const nx = nc * CELL_SIZE;
      const ny = nr * CELL_SIZE;
      ctx.translate(nx, ny);

      const targetIdx  = targetRow * COLS + targetCol;
      const targetCell = cells[targetIdx];

      for (const s of nCell.shapes) {
        // If PLUS is next to PLUS, or CROSS next to CROSS,
        // do NOT draw neighbor overshoot into the target cell.
        // This prevents color overlap and forces a clean midpoint meeting.
        if (s.shape === "plus" || s.shape === "cross") {
        const sameShapeInTarget = targetCell.shapes.some(t => t.shape === s.shape);
        if (sameShapeInTarget) continue;
        }

        drawShape(ctx, CELL_SIZE, s.shape, s.color);

      }
    
      ctx.restore();
    }
    
    function drawShape(ctx, s, shape, color, shrink=false){
      const scale = s / 10;
      ctx.lineJoin = "miter";
      ctx.lineCap  = "square";
    
      switch (shape) {
        case "cross": {
          ctx.strokeStyle = color;
          ctx.lineWidth = 1.8 * scale;
          const adjCross = shrink ? 0.9 * scale : 0;
    
          ctx.beginPath();
          ctx.moveTo(adjCross, adjCross);
          ctx.lineTo(10 * scale - adjCross, 10 * scale - adjCross);
          ctx.moveTo(adjCross, 10 * scale - adjCross);
          ctx.lineTo(10 * scale - adjCross, adjCross);
          ctx.stroke();
          break;
        }
    
        case "plus": {
          ctx.strokeStyle = color;
          ctx.lineWidth = 1.8 * scale;
          const adjPlus = shrink ? 0.9 * scale : 0;
    
          ctx.beginPath();
          ctx.moveTo(adjPlus, 5 * scale);
          ctx.lineTo(10 * scale - adjPlus, 5 * scale);
          ctx.moveTo(5 * scale, adjPlus);
          ctx.lineTo(5 * scale, 10 * scale - adjPlus);
          ctx.stroke();
          break;
        }
    
        case "box-line":
          ctx.strokeStyle = color;
          ctx.lineWidth = 1.8 * scale;
          ctx.strokeRect(1.68 * scale, 1.68 * scale, 6.64 * scale, 6.64 * scale);
          break;
    
        case "box-filled":
          ctx.fillStyle   = color;
          ctx.strokeStyle = color;
          ctx.lineWidth   = 1.8 * scale;
          ctx.fillRect(1.68 * scale, 1.68 * scale, 6.64 * scale, 6.64 * scale);
          ctx.strokeRect(1.68 * scale, 1.68 * scale, 6.64 * scale, 6.64 * scale);
          break;
    
        case "box-small-line":
          ctx.strokeStyle = color;
          ctx.lineWidth = 1.8 * scale;
          ctx.strokeRect(3.11 * scale, 3.11 * scale, 3.79 * scale, 3.79 * scale);
          break;
    
        case "box-small-filled":
          ctx.fillStyle   = color;
          ctx.strokeStyle = color;
          ctx.lineWidth   = 1.8 * scale;
          ctx.fillRect(3.11 * scale, 3.11 * scale, 3.79 * scale, 3.79 * scale);
          ctx.strokeRect(3.11 * scale, 3.11 * scale, 3.79 * scale, 3.79 * scale);
          break;
    
        case "circle-line":
          ctx.strokeStyle = color;
          ctx.lineWidth = 1.8 * scale;
          ctx.beginPath();
          ctx.arc(5 * scale, 5 * scale, 3.32 * scale, 0, Math.PI * 2);
          ctx.stroke();
          break;
    
        case "circle-filled":
          ctx.fillStyle   = color;
          ctx.strokeStyle = color;
          ctx.lineWidth   = 1.8 * scale;
          ctx.beginPath();
          ctx.arc(5 * scale, 5 * scale, 3.32 * scale, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          break;
    
        case "circle-small-line":
          ctx.strokeStyle = color;
          ctx.lineWidth = 1.8 * scale;
          ctx.beginPath();
          ctx.arc(5 * scale, 5 * scale, 1.89 * scale, 0, Math.PI * 2);
          ctx.stroke();
          break;
    
        case "circle-small-filled":
          ctx.fillStyle   = color;
          ctx.strokeStyle = color;
          ctx.lineWidth   = 1.8 * scale;
          ctx.beginPath();
          ctx.arc(5 * scale, 5 * scale, 1.89 * scale, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          break;
      }
    }
    
    /* ===========================================
       PAINTING
    =========================================== */
    function paintAt(row, col) {
      const size = brushSize;
      const half = (size - 1) / 2;
    
      for (let r = -half; r <= half; r++) {
        for (let c = -half; c <= half; c++) {
          const rr = row + Math.round(r);
          const cc = col + Math.round(c);
    
          if (rr < 0 || rr >= ROWS || cc < 0 || cc >= COLS) continue;
    
          const idx  = rr * COLS + cc;
          const cell = cells[idx];
    
          if (brushShape === "eraser") {
            cell.fillColor = null;
            cell.shapes = [];
    
            drawCell(rr, cc);
    
            const px = cc * CELL_SIZE;
            const py = rr * CELL_SIZE;
            const margin = 2;
    
            ctx.save();
            ctx.beginPath();
            ctx.rect(px - margin, py - margin, CELL_SIZE + margin * 2, CELL_SIZE + margin * 2);
            ctx.clip();
    
            ctx.clearRect(px - margin, py - margin, CELL_SIZE + margin * 2, CELL_SIZE + margin * 2);
            ctx.fillStyle = "white";
            ctx.fillRect(px - margin, py - margin, CELL_SIZE + margin * 2, CELL_SIZE + margin * 2);
    
            ctx.restore();
    
            for (let nr = rr - 1; nr <= rr + 1; nr++) {
              for (let nc = cc - 1; nc <= cc + 1; nc++) {
                if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
                drawCell(nr, nc);
              }
            }
          }
          else if (brushShape === "fill") {
            cell.fillColor = brushColor;
            drawCell(rr, cc);
          }
          else {
            cell.shapes = cell.shapes.filter(
              s => !(s.shape === brushShape && s.color === brushColor)
            );
            cell.shapes.push({ shape: brushShape, color: brushColor });
            drawCell(rr, cc);
          }
        }
      }
    }
    
    function drawLine(r1, c1, r2, c2) {
      let x0 = c1, y0 = r1;
      let x1 = c2, y1 = r2;
    
      let dx = Math.abs(x1 - x0);
      let dy = Math.abs(y1 - y0);
      let sx = x0 < x1 ? 1 : -1;
      let sy = y0 < y1 ? 1 : -1;
      let err = dx - dy;
    
      while (true) {
        paintAt(y0, x0);
        if (x0 === x1 && y0 === y1) break;
        const e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x0 += sx; }
        if (e2 <  dx) { err += dx; y0 += sy; }
      }
    }
    
    /* ===========================================
       POINTER EVENTS
    =========================================== */
    let drawing = false;
    let prevRow = null;
    let prevCol = null;
    
    canvas.addEventListener("pointerdown", e => {
      if (drawingLocked) return;     // completely ignore drawing
      const cell = getCellFromEvent(e);
      if (!cell) return;
      drawing = true;
      prevRow = cell.row;
      prevCol = cell.col;
      paintAt(cell.row, cell.col);
    
      const overlay = document.getElementById("promptOverlay");
        // If cycle done → hide overlay and allow drawing
        if (!overlay.classList.contains("hidden")) {
            overlay.classList.add("hidden");
        }
    });
    
    canvas.addEventListener("pointermove", e => {
      if (drawingLocked) return;
      if (!drawing) return;
      const cell = getCellFromEvent(e);
      if (!cell) return;
      if (cell.row === prevRow && cell.col === prevCol) return;
      drawLine(prevRow, prevCol, cell.row, cell.col);
      prevRow = cell.row;
      prevCol = cell.col;
    });
    
    window.addEventListener("pointerup", () => {
      drawing = false;
      prevRow = null;
      prevCol = null;
    });
    
    /* ===========================================
       TIMER (HIDE SELECTORS OVER TIME)
    =========================================== */
    function countVisibleMovableCubes() {
      return selectorCells.filter(c =>
        !c.classList.contains("hidden") &&
        !c.classList.contains("punished")
      ).length;
    }

    function startHideTimer() {
      if (hideTimerId !== null) {
        clearInterval(hideTimerId);
        hideTimerId = null;
      }

      timerCountdown = countdownValue;
      disappearPercentage = 20;

      hideTimerId = setInterval(() => {
        timerCountdown--;

        // Check total visible cubes
        const visibleCount = countVisibleMovableCubes();

        // STOP decay permanently when only 4 cubes remain visible
        if (visibleCount <= 4) {
          disappearPercentage = 100;   // force `randomizeSelectors()` to hide nothing extra
          timerCountdown = countdownValue;
          return;
        }

        // Normal decay
        if (timerCountdown <= 0) {
          disappearPercentage = Math.min(disappearPercentage + 10, 100);
          timerCountdown = countdownValue;
        }

      }, 1000);
    }

    
    function stopHideTimer() {
      if (hideTimerId !== null) {
        clearInterval(hideTimerId);
        hideTimerId = null;
      }
    }
    
    /* ===========================================
       SOFT RESET (inside drawing session)
    =========================================== */
    function softReset() {
      cells.forEach(c => {
        c.fillColor = null;
        c.shapes = [];
      });
    
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, cssWidth, cssHeight);
    
      disappearPercentage = 20;
      timerCountdown = countdownValue;
    
      buildSelectorCells();
    
      if (hideTimerId !== null) {
        clearInterval(hideTimerId);
        hideTimerId = null;
      }
      startHideTimer();
    }
    
  /* ===========================================
   UPLOAD TO WORKER / R2 — PROMPT-BASED
    =========================================== */
    async function uploadToR2(fileBlob, promptWord) {
    const form = new FormData();
    form.append("file", fileBlob);
    form.append("prompt", promptWord);  // Worker will name + number it

    const res = await fetch("https://toolkit-uploader.toolkit-toontoolkit-toon.workers.dev", {
        method: "POST",
        body: form
    });

    if (!res.ok) {
        console.error("Upload failed:", await res.text());
        throw new Error("Upload failed");
    }

    const data = await res.json();
    console.log("Uploaded:", data);
    return data.url; // contains final key like HOUSE-003.png
    }


    /* ===========================================
       WIPE ANIMATION — CLEAR CANVAS ROW BY ROW
    =========================================== */
    async function wipeCanvasAnimation() {
      const totalRows = ROWS;
      const rowHeight = CELL_SIZE;
      const delay = 20; // ms per row
    
      for (let r = 0; r < totalRows; r++) {
        const y = r * rowHeight;
        ctx.fillStyle = "white";
        ctx.fillRect(0, y, cssWidth, rowHeight);
        await new Promise(res => setTimeout(res, delay));
      }
    }

    async function showExportMessage() {
    const overlay = document.getElementById("exportMessageOverlay");

    drawingLocked = true;    // ensure drawing stays blocked

    overlay.classList.add("show");

    // Show for ~1.2 sec
    await new Promise(res => setTimeout(res, 2500));

    overlay.classList.remove("show");
}
    
    /* ===========================================
       EXPORT (UPLOAD + WIPE + RETURN TO START)
    =========================================== */
    function exportVisibleCanvas() {
      if (saveLocked) return;   // <<< HARD GUARD
      saveLocked = true;

      drawingLocked = true;   // stop drawing from this moment on

      console.clear();
      console.log("=== EXPORT DEBUG START ===");
    
      const wrap = document.querySelector(".canvas-wrap");
      const wrapRect = wrap.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
    
      const BORDER = 14;
    
      let rawX = BORDER;
      let rawY = 0;
      let rawW = wrapRect.width - BORDER * 2;
      let rawH = wrapRect.height;
    
      const cell = CELL_SIZE;
      let snapX = Math.ceil(rawX / cell) * cell;
      let snapY = Math.ceil(rawY / cell) * cell;
      let endX = Math.floor((rawX + rawW) / cell) * cell;
      let endY = Math.floor((rawY + rawH) / cell) * cell;
    
      let snapW = endX - snapX;
      let snapH = endY - snapY;
    
      const cropX = snapX * dpr;
      const cropY = snapY * dpr;
      const cropW = snapW * dpr;
      const cropH = snapH * dpr;
    
      const temp = document.createElement("canvas");
      temp.width = cropW;
      temp.height = cropH;
      const tctx = temp.getContext("2d");
    
      tctx.drawImage(
        canvas,
        cropX, cropY, cropW, cropH,
        0, 0, cropW, cropH
      );
    
      temp.toBlob(async (blob) => {
    const promptWord = document.getElementById("promptTarget").textContent.trim();

    // --- NEW: trigger local download ---
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${promptWord || "drawing"}.png`; // name it after prompt or fallback
    a.click();
    URL.revokeObjectURL(url);
    // --- END DOWNLOAD ---

    try {
        await uploadToR2(blob, promptWord);
        console.log("Uploaded using Worker KV logic for prompt:", promptWord);
    } catch (err) {
        console.error("R2 upload failed:", err);
        alert("Upload failed. Check console.");
        return;
    }

    console.log("=== EXPORT DEBUG END ===");

    // 1. play wipe animation
    await wipeCanvasAnimation();

    // 2. Show export message in the center
    await showExportMessage();

    // 3. Go back to start screen
    const startScreen   = document.getElementById("startScreen");
    const drawingScreen = document.getElementById("drawingScreen");

    drawingScreen.style.display = "none";
    startScreen.style.display = "flex";

    drawingLocked = false;   // allow drawing again after returning to start screen
}, "image/png");

    }
    
    /* ===========================================
       BUTTON HANDLERS
    =========================================== */
    
    /* Large-screen export button */
    exportBtn.addEventListener("click", () => {
    if (!document.getElementById("promptOverlay").classList.contains("hidden")) return;
    exportVisibleCanvas();
    });

    
    /* RESET / SAVE behavior (works for both modes) */
    resetBtn.addEventListener("click", () => {
    const overlayVisible = !document.getElementById("promptOverlay").classList.contains("hidden");
    if (overlayVisible) return;

    const mode = resetBtn.getAttribute("data-mode");

    if (mode === "reset") {
        softReset();
    } else if (mode === "export") {
        exportVisibleCanvas();
    }
});

    
    /* ===========================================
       RESET ↔ EXPORT TOGGLER (SMALL MODE)
    =========================================== */
    (function () {
      let showingReset = true;
      let isHovering   = false;
    
      function toggleButtons() {
        if (isHovering) return;
    
        const exportVisible = window.getComputedStyle(exportBlock).display !== "none";
    
        // LARGE MODE → no toggle, just RESET
        if (exportVisible) {
          resetBtn.querySelector("span").textContent = "RESET";
          resetBtn.setAttribute("data-mode", "reset");
          return;
        }
    
        // SMALL MODE → toggle RESET ↔ SAVE
        showingReset = !showingReset;
    
        if (showingReset) {
          resetBtn.querySelector("span").textContent = "RESET";
          resetBtn.setAttribute("data-mode", "reset");
        } else {
          resetBtn.querySelector("span").textContent = "SAVE";
          resetBtn.setAttribute("data-mode", "export");
        }
      }
    
      resetBtn.addEventListener("mouseenter", () => { isHovering = true;  });
      resetBtn.addEventListener("mouseleave", () => { isHovering = false; });
    
      setInterval(toggleButtons, 1500);
      toggleButtons();
    })();
    
    /* ===========================================
       RANDOM PROMPT GENERATOR
    =========================================== */
    const promptWords = [
      "FACE",
      "DOG",
      "CAT",
      "CAR",
      "HOUSE",
      "???",
      "FISH",
      "FLOWER",
      "FRUIT"
    ];
    
    function setRandomPrompt() {
      const word = promptWords[Math.floor(Math.random() * promptWords.length)];
      const target = document.getElementById("promptTarget");
      if (!target) return;
      target.innerHTML = `${word}`;
    }
    
    function cyclePrompt(duration = 1000) {
    const target = document.getElementById("promptTarget");
    const overlay = document.getElementById("promptOverlay");
    const overlayText = document.getElementById("promptOverlayText");

    if (!target || !overlay || !overlayText) return;

    // Overlay must be visible AND drawing must be blocked
    overlay.classList.remove("hidden");
    drawingLocked = true;

    // Clear old timers
    if (promptCycleIntervalId !== null) {
        clearInterval(promptCycleIntervalId);
        promptCycleIntervalId = null;
    }
    if (promptCycleTimeoutId !== null) {
        clearTimeout(promptCycleTimeoutId);
        promptCycleTimeoutId = null;
    }

    // Fast spin
    promptCycleIntervalId = setInterval(() => {
        const word = promptWords[Math.floor(Math.random() * promptWords.length)];
        target.textContent = word;
        overlayText.textContent = word;  // sync
    }, 30);

    // Stop after duration
    promptCycleTimeoutId = setTimeout(() => {
    clearInterval(promptCycleIntervalId);
    promptCycleIntervalId = null;

    const finalWord = promptWords[Math.floor(Math.random() * promptWords.length)];
    target.textContent = finalWord;
    overlayText.textContent = finalWord;

    // Keep overlay visible but now allow clicking to dismiss
    drawingLocked = false;

    // >>> FIX: show the helper labels again <<<
    document.getElementById("click-overlay").style.display = "block";
    document.getElementById("click-overlay-2").style.display = "block";

    promptCycleTimeoutId = null;
}, duration);
}

    /* ===========================================
       SESSION RESET + START
    =========================================== */
    function resetDrawingSessionState() {
      cells.forEach(c => {
        c.fillColor = null;
        c.shapes = [];
      });
    
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, cssWidth, cssHeight);
    
      disappearPercentage = 20;
      timerCountdown = countdownValue;
    
      buildSelectorCells();
    }
    
    function startDrawingSession() {
      saveLocked = false; 
      resetDrawingSessionState();
      updateCursor();

      drawingLocked = true;
      startHideTimer();
      cyclePrompt(1000);
    }
    
    /* ===========================================
       START SCREEN -> DRAWING SCREEN
    =========================================== */
    window.onload = () => {
      const startBtn      = document.getElementById("startButton");
      const startScreen   = document.getElementById("startScreen");
      const drawingScreen = document.getElementById("drawingScreen");
    
      if (startBtn) {
        startBtn.addEventListener("click", () => {
          if (startScreen)   startScreen.style.display   = "none";
          if (drawingScreen) drawingScreen.style.display = "block";
    
          startHideTimer();
          startDrawingSession();
          startSessionInactivity();
    
          requestAnimationFrame(() => {
            window.dispatchEvent(new Event("resize"));
          });
        });
      }
    };
    
    /* ===========================================
       LEAVE BUTTON
    =========================================== */
    document.getElementById("leave").addEventListener("click", () => {
      location.reload();
    });


    window.addEventListener("mouseenter", updateCursor);
window.addEventListener("focus", updateCursor);
document.addEventListener("visibilitychange", () => {
  if (!document.hidden) updateCursor();
});

window.addEventListener("pointermove", ensureCursor, { passive: true });


    
    console.log("END OF BODY REACHED");
</script>
    
</body>
</html>
